import{useRef as t,useEffect as r,useCallback as s}from"react";const e=(t,r)=>new Promise((s,e)=>{const n=setTimeout(s,t);r.addEventListener("abort",()=>{clearTimeout(n),e("aborted")})});class n{constructor(t={}){this.ctx=t,this.ops=[],this.controller=null,this.cancelHandlers=[],this.onStartHandlers=[],this.onDoneHandlers=[],this.onErrorHandlers=[]}static from(t,r){const s=new n(r);return s.initialInput=t,s}async run(t){var r;const s=void 0!==t?t:this.initialInput;if(void 0===s)throw Error("Flow.run: missing input");null===(r=this.controller)||void 0===r||r.abort(),this.controller=new AbortController,this.onStartHandlers.forEach(t=>t());let e=s;try{for(const t of this.ops){if(this.controller.signal.aborted)return;await this.waitIfPaused(),e=await t(e,this.ctx,this.controller.signal)}return this.onDoneHandlers.forEach(t=>t()),e}catch(t){if(t===n.SKIP)return;throw this.onErrorHandlers.forEach(r=>r(t)),t}}onStart(t){return this.onStartHandlers.push(t),this}onDone(t){return this.onDoneHandlers.push(t),this}onError(t){return this.onErrorHandlers.push(t),this}onCancel(t){return this.cancelHandlers.push(t),this}cancel(){var t;null===(t=this.controller)||void 0===t||t.abort(),this.cancelHandlers.forEach(t=>t())}pause(){return this.paused||(this.paused=new Promise(t=>this.resume=t)),this}resumeFlow(){return this.paused&&(this.resume(),this.paused=void 0),this}async waitIfPaused(){this.paused&&await this.paused}context(){return this.ctx}step(t){return this.ops.push(t),this}tap(t){return this.step((r,s)=>(t(r,s),r))}filter(t){return this.step(r=>{if(!t(r))throw n.SKIP;return r})}debounce(t){return this.step(async(r,s,n)=>(await e(t,n),r))}leading(t){let r=!1;return this.step(async s=>{if(r)throw n.SKIP;return r=!0,setTimeout(()=>r=!1,t),s})}throttle(t){return this.leading(t)}take(t){let r=0;return this.step(s=>{if(++r>t)throw n.SKIP;return s})}switchMap(t){let r=null;return this.step(async(s,e,n)=>(null==r||r.abort(),r=new AbortController,n.addEventListener("abort",()=>null==r?void 0:r.abort()),t(s,e,r.signal)))}exhaustMap(t){let r=!1;return this.step(async(s,e,i)=>{if(r)throw n.SKIP;r=!0;try{return await t(s,e,i)}finally{r=!1}})}retry(t){const r=this.ops.pop();if(!r)return this;const s="number"==typeof t?{times:t}:t,{times:n,delay:i=0,backoff:o}=s;return this.ops.push(async(t,s,a)=>{let u=0;for(;;)try{return await r(t,s,a)}catch(t){if(u++,u>n)throw t;if(i>0){const t="exponential"===o?i*Math.pow(2,u-1):"linear"===o?i*u:i;await e(t,a)}}}),this}poll(t){const r=this.ops.pop();if(!r)return this;return this.ops.push(async(s,n,i)=>{let o=await r(s,n,i);for(;;)await e(t,i),o=await r(o,n,i)}),this}timeout(t){const r=this.ops.pop();if(!r)return this;return this.ops.push((s,n,i)=>Promise.race([r(s,n,i),e(t,i).then(()=>{throw Error("timeout")})])),this}catch(t){const r=this.ops.pop();if(!r)return this;return this.ops.push(async(s,e,n)=>{try{return await r(s,e,n)}catch(r){return t(r,e)}}),this}}function i(e,i,o){const a=t(null),u=t(null!=o?o:{});u.current=null!=o?o:u.current,r(()=>{var t;null===(t=a.current)||void 0===t||t.cancel();const r=n.from(e,u.current),s=i(r);return a.current=s,s.run(),()=>s.cancel()},[e,i]);return{cancel:s(()=>{var t;null===(t=a.current)||void 0===t||t.cancel()},[]),pause:s(()=>{var t;null===(t=a.current)||void 0===t||t.pause()},[]),resume:s(()=>{var t;null===(t=a.current)||void 0===t||t.resumeFlow()},[]),flow:a.current}}n.SKIP=Symbol("FLOW_SKIP");export{n as Flow,e as sleep,i as useFlow};
