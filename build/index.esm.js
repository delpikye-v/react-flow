import{useRef as t,useEffect as r,useCallback as n}from"react";const e=(t,r)=>new Promise((n,e)=>{const s=setTimeout(n,t);r.addEventListener("abort",()=>{clearTimeout(s),e("aborted")})});class s{constructor(t={}){this.ctx=t,this.ops=[],this.controller=null,this.cancelHandlers=[],this.onStartHandlers=[],this.onDoneHandlers=[],this.onErrorHandlers=[]}static from(t,r){const n=new s(r);return n.initialInput=t,n}async run(t){var r;const n=void 0!==t?t:this.initialInput;if(void 0===n)throw Error("Flow.run: missing input");null===(r=this.controller)||void 0===r||r.abort(),this.controller=new AbortController,this.onStartHandlers.forEach(t=>t());let e=n;try{for(const t of this.ops){if(this.controller.signal.aborted)return;await this.waitIfPaused(),e=await t(e,this.ctx,this.controller.signal)}return this.onDoneHandlers.forEach(t=>t()),e}catch(t){if(t===s.SKIP)return;throw this.onErrorHandlers.forEach(r=>r(t)),t}}onStart(t){return this.onStartHandlers.push(t),this}onDone(t){return this.onDoneHandlers.push(t),this}onError(t){return this.onErrorHandlers.push(t),this}onCancel(t){return this.cancelHandlers.push(t),this}cancel(){var t;null===(t=this.controller)||void 0===t||t.abort(),this.cancelHandlers.forEach(t=>t())}pause(){return this.paused||(this.paused=new Promise(t=>this.resume=t)),this}resumeFlow(){return this.paused&&(this.resume(),this.paused=void 0),this}async waitIfPaused(){this.paused&&await this.paused}context(){return this.ctx}step(t){return this.ops.push(t),this}tap(t){return this.step((r,n)=>(t(r,n),r))}filter(t){return this.step(r=>{if(!t(r))throw s.SKIP;return r})}debounce(t){return this.step(async(r,n,s)=>(await e(t,s),r))}leading(t){let r=!1;return this.step(async n=>{if(r)throw s.SKIP;return r=!0,setTimeout(()=>r=!1,t),n})}throttle(t){return this.leading(t)}take(t){let r=0;return this.step(n=>{if(++r>t)throw s.SKIP;return n})}switchMap(t){let r=null;return this.step(async(n,e,s)=>(null==r||r.abort(),r=new AbortController,s.addEventListener("abort",()=>null==r?void 0:r.abort()),t(n,e,r.signal)))}exhaustMap(t){let r=!1;return this.step(async(n,e,i)=>{if(r)throw s.SKIP;r=!0;try{return await t(n,e,i)}finally{r=!1}})}retry(t){const r=this.ops.pop();if(!r)return this;return this.ops.push(async(n,e,s)=>{let i=0;for(;;)try{return await r(n,e,s)}catch(r){if(++i>t)throw r}}),this}timeout(t){const r=this.ops.pop();if(!r)return this;return this.ops.push((n,s,i)=>Promise.race([r(n,s,i),e(t,i).then(()=>{throw Error("timeout")})])),this}catch(t){const r=this.ops.pop();if(!r)return this;return this.ops.push(async(n,e,s)=>{try{return await r(n,e,s)}catch(r){return t(r,e)}}),this}}function i(e,i,o){const a=t(null),u=t(null!=o?o:{});u.current=null!=o?o:u.current,r(()=>{var t;null===(t=a.current)||void 0===t||t.cancel();const r=s.from(e,u.current),n=i(r);return a.current=n,n.run(),()=>n.cancel()},[e,i]);return{cancel:n(()=>{var t;null===(t=a.current)||void 0===t||t.cancel()},[]),pause:n(()=>{var t;null===(t=a.current)||void 0===t||t.pause()},[]),resume:n(()=>{var t;null===(t=a.current)||void 0===t||t.resumeFlow()},[]),flow:a.current}}s.SKIP=Symbol("FLOW_SKIP");export{s as Flow,e as sleep,i as useFlow};
