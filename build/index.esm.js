import{useRef as t,useEffect as r,useCallback as n}from"react";const s=(t,r)=>new Promise((n,s)=>{const e=setTimeout(n,t);r.addEventListener("abort",()=>{clearTimeout(e),s("aborted")})});class e{constructor(t={}){this.ctx=t,this.ops=[],this.controller=null,this.cancelHandlers=[],this.onStartHandlers=[],this.onDoneHandlers=[],this.onErrorHandlers=[],this.finallyHandlers=[]}static from(t,r){const n=new e(r);return n.initialInput=t,n}async run(t){var r;const n=void 0!==t?t:this.initialInput;if(void 0===n)throw Error("Flow.run: missing input");null===(r=this.controller)||void 0===r||r.abort(),this.controller=new AbortController,this.onStartHandlers.forEach(t=>t());let s=n;try{for(const t of this.ops){if(this.controller.signal.aborted)return;await this.waitIfPaused(),s=await t(s,this.ctx,this.controller.signal)}return this.onDoneHandlers.forEach(t=>t()),s}catch(t){if(t===e.SKIP)return;throw this.onErrorHandlers.forEach(r=>r(t)),t}finally{this.finallyHandlers.forEach(t=>t())}}onStart(t){return this.onStartHandlers.push(t),this}onDone(t){return this.onDoneHandlers.push(t),this}onError(t){return this.onErrorHandlers.push(t),this}onCancel(t){return this.cancelHandlers.push(t),this}cancel(){var t;null===(t=this.controller)||void 0===t||t.abort(),this.cancelHandlers.forEach(t=>t())}pause(){return this.paused||(this.paused=new Promise(t=>this.resume=t)),this}resumeFlow(){return this.paused&&(this.resume(),this.paused=void 0),this}async waitIfPaused(){this.paused&&await this.paused}context(){return this.ctx}step(t){return this.ops.push(t),this}tap(t){return this.step((r,n)=>(t(r,n),r))}filter(t){return this.step(r=>{if(!t(r))throw e.SKIP;return r})}debounce(t){return this.step(async(r,n,e)=>(await s(t,e),r))}leading(t){let r=!1;return this.step(async n=>{if(r)throw e.SKIP;return r=!0,setTimeout(()=>r=!1,t),n})}throttle(t){return this.leading(t)}take(t){let r=0;return this.step(n=>{if(++r>t)throw e.SKIP;return n})}map(t){return this.step((r,n)=>t(r,n))}switchMap(t){let r=null;return this.step(async(n,s,e)=>(null==r||r.abort(),r=new AbortController,e.addEventListener("abort",()=>null==r?void 0:r.abort()),t(n,s,r.signal)))}exhaustMap(t){let r=!1;return this.step(async(n,s,i)=>{if(r)throw e.SKIP;r=!0;try{return await t(n,s,i)}finally{r=!1}})}distinct(t=Object.is){let r,n=!1;return this.step(s=>{if(n&&t(r,s))throw e.SKIP;return n=!0,r=s,s})}retry(t){const r=this.ops.pop();if(!r)return this;const n="number"==typeof t?{times:t}:t,{times:e,delay:i=0,backoff:o}=n;return this.ops.push(async(t,n,a)=>{let l=0;for(;;)try{return await r(t,n,a)}catch(t){if(l++,l>e)throw t;if(i>0){const t="exponential"===o?i*Math.pow(2,l-1):"linear"===o?i*l:i;await s(t,a)}}}),this}poll(t,r){const n=this.ops.pop();if(!n)return this;const{until:e,max:i}=r||{};return this.ops.push(async(r,o,a)=>{let l,u=0;for(;;){if(l=await n(r,o,a),null==e?void 0:e(l))return l;if(i&&++u>=i)throw Error("poll max reached");await s(t,a)}}),this}timeout(t){const r=this.ops.pop();if(!r)return this;return this.ops.push((n,e,i)=>Promise.race([r(n,e,i),s(t,i).then(()=>{throw Error("timeout")})])),this}catch(t){const r=this.ops.pop();if(!r)return this;return this.ops.push(async(n,s,e)=>{try{return await r(n,s,e)}catch(r){return t(r,s)}}),this}finally(t){return this.finallyHandlers.push(t),this}}function i(s,i,o){const a=t(null),l=t(null!=o?o:{});l.current=null!=o?o:l.current,r(()=>{var t;null===(t=a.current)||void 0===t||t.cancel();const r=e.from(s,l.current),n=i(r);return a.current=n,n.run(),()=>n.cancel()},[s,i]);return{cancel:n(()=>{var t;null===(t=a.current)||void 0===t||t.cancel()},[]),pause:n(()=>{var t;null===(t=a.current)||void 0===t||t.pause()},[]),resume:n(()=>{var t;null===(t=a.current)||void 0===t||t.resumeFlow()},[]),flow:a.current}}e.SKIP=Symbol("FLOW_SKIP");export{e as Flow,s as sleep,i as useFlow};
